import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark } from "@code-surfer/themes";
import "prismjs/components/prism-erlang";

export const theme = vsDark;

# Julia's Child
Fine, French Programming
<img src="https://www.pbs.org/wnet/americanmasters/files/2005/06/JuliaChild-16x9-400x400.jpg"/>

<Notes>
- These are speaker notes
- And they won't be rendered in your slide
</Notes>

---

# Start with "Why?"

---

# Start with "Why?"
<!-- Should be able to use a step tag but code surfer is broken -->
Why do we use programming languages

<Notes>
- Do things faster
- Repetitive
- Parallelization
</Notes>

---

# Start with "Why?"

Why do we use programming languages
- Do things faster

---

# Start with "Why?"

Why do we use programming languages
- Do things faster
- Repetitive tasks

---

# Start with "Why?"

Why do we use programming languages
- Do things faster
- Repetitive tasks
- Parallel work

---

# Start with "Why?"

Why should we consider another language

---

# Start with "Why?"

Why should we consider another language
- "Sharpen the saw"

---

# Start with "Why?"

Why should we consider another language
- "Sharpen the saw"
- Solve the "two-language" problem

<Notes>
- One language for proof of concept
- One language for efficiency
</Notes>

---

<Notes>
- 3rd problem is generality
</Notes>

<CodeSurferColumns themes={[vsDark, github]}>

<Step title="The two language problem">

```c
#include <stddef.h>
double c_sum(size_t n, double *X) {
    double s = 0.0;
    for (size_t i = 0; i < n; ++i) {
        s += X[i];
    }
    return s;
}
```

<div>
<h1>Performance</h1>
C, Fortran, Assembly
</div>

</Step>

<Step title="The two language problem">

```python
def py_sum(A):
    s = 0.0
    for a in A:
        s += a
    return s
```

<div>
<h1>Prototyping</h1>
Python, Ruby, MATLAB
</div>

</Step>

</CodeSurferColumns>

---

looks like **python**, runs like **C**

---

# Runs like C

<math xmlns="http://www.w3.org/1998/Math/MathML">
  <mstyle displaystyle="true">
    <mrow class="MJX-TeXAtom-ORD">
      <mi>s</mi>
      <mi>u</mi>
      <mi>m</mi>
      <mo stretchy="false">(</mo>
      <mi>a</mi>
      <mo stretchy="false">)</mo>
      <mo>=</mo>
      <munderover>
        <mo movablelimits="false">&#x2211;</mo>
        <mrow class="MJX-TeXAtom-ORD">
          <mi>i</mi>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
        <mrow class="MJX-TeXAtom-ORD">
          <mi>n</mi>
        </mrow>
      </munderover>
      <mrow class="MJX-TeXAtom-ORD">
        <msub>
          <mi>a</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>i</mi>
          </mrow>
        </msub>
      </mrow>
    </mrow>
  </mstyle>
</math>

- C: 10 ms
- python: 500 ms
- julia: 10 ms

<Notes>
- 10 million element vector
</Notes>

---

<CodeSurfer>

<!-- Using the Erlang syntax highlighting because Prism's julia one is bad -->
```python title="Looks like python"
def sum(a):
    s = 0.0
    for x in a:
        s += x
    return s
```

```erlang title="Looks like python" subtitle="Julia version"
function sum(a)
    s = 0.0
    for x in a
        s += x
    end
    return s
end
```

</CodeSurfer>

---

# How can we do this?

- Free and open source (MIT licensed)
- Generates LLVM IR
- User-defined types are as fast and compact as built-ins
- No need to vectorize code for performance; devectorized code is fast

---

# How can we do this?

- Designed for parallelism and distributed computation
- Lightweight "green" threading (coroutines)
- Unobtrusive yet powerful type system
- Call C functions directly (no wrappers or special APIs needed)
- Powerful shell-like capabilities for managing other processes

---

# Julia

---

# Use Case Example
### Celeste Project

---

# Celeste Project
- Sloan Digital Sky Survey data
- 178 Terabytes of data

---

# Celeste Project
- 9300 KNL nodes at NERSC
- 188 million stars/galaxies
- < 15 minutes of run time
- 1.54 petaflops
- 1.3 million threads

<Notes>
- 3rd language to bypass petaflops
- FORTRAN and C
</Notes>

---

# Why use Julia for Celeste?

<Notes>
- same language for whole team
- subject matter expert vs computer scientist
</Notes>

---

# Why use Julia for Celeste?

- same language for whole team
- subject matter expert vs computer scientist

---

<CodeSurfer>

<!-- Using the Erlang syntax highlighting because Prism's julia one is bad -->
```erlang title="Getting Started"
my_answer = 42
typeof(my_answer)
# Int64

my_pi = 3.14159
typeof(my_pi)
# Float64

my_str = "Some string"
typeof(my_str)
# String

println("I'm excited to learn Julia!")

# using single line comments like this

#=
  using multiline comments
  can be done
  like this
=#

sum = 3 + 7

difference = 10 - 3

product = 20 * 5

quotient = 100 / 10

power = 10 ^ 2

modulus = 101 % 2
```

<!-- show int -->
```diff 1:3 subtitle="Assigning Integers"

```
<!-- show float -->
```diff 5:7 subtitle="Assigning Floats"

```
<!-- show string -->
```diff 9:11 subtitle="Assigning Strings"

```
<!-- show print -->
```diff 13 subtitle="How to Print"

```
<!-- show comment -->
```diff 15 subtitle="How to comment"

```
<!-- show multiline comment -->
```diff 17:21 subtitle="How to comment on multiple lines"

```
<!-- show sum -->
```diff 23 subtitle="Addition operator"

```
<!-- show subtraction -->
```diff 25 subtitle="Subtraction operator"

```
<!-- show multiply -->
```diff 27 subtitle="Multiplication operator"

```
<!-- show division -->
```diff 29 subtitle="Division operator"

```
<!-- show exponent -->
```diff 31 subtitle="Power operator"

```
<!-- show modulo -->
```diff 33 subtitle="Modulus operator"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Strings and Things"
s1 = "I am a string."
s2 = """I am also a "special" string. """
formatted = """I am a formated string


with newlines"""

typeof('a')
# Char

name = "Jane"
num_fingers = 10
num_toes = 10

println("Hello, my name is $name.")
println("I have $num_fingers fingers and $num_toes toes.")

println("That is $(num_fingers + num_toes) total digits.")

s3 = "How many dogs ";
s4 = "is too many dogs?";
dogs = 10

string(s3, s4)
# "How many dogs is too many dogs?"

string("I don't know, but ", dogs, " is too few.")
# "I don't know, but 10 is too few."

s3*s4
# "How many dogs is too many dogs?"

```

<!-- show strings -->
```diff 1:2 subtitle="Basic Strings"

```
<!-- show formatted strings -->
```diff 3:6 subtitle="Formatted Strings"

```
<!-- show char -->
```diff 8:9 subtitle="Char is not a String"

```
<!-- show interpolation -->
```diff 11:18 subtitle="String Interpolation"

```
<!-- show concat -->
```diff 20:31 subtitle="String Concatenation"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Data Structures"
my_pets = ("cat", "dog", "gecko")
my_pets[1])
# "cat"

my_pets[1] = "rock"
# a MethodError will occur, tuples are immutable

my_named_pets = (cat = "alice", dog = "bob", gecko = "charlie")
my_named_pets[1]
# "alice"
my_named_pets.gecko
# "charlie"

my_dictionary = Dict()
# Dict{Any, Any}
my_contacts = Dict("Jenny" => "867-5309", "Ghostbusters" => "555-2368")

my_contacts["Jenny"]
# "867-5309"

my_contacts["Kramer"] = "555-FILK"
my_contacts["Kramer"]
# "555-FILK"

pop!(my_contacts, "Kramer")

my_friends = ["Rachel", "Monica", "Phoebe", "Joey", "Chandler", "Ross"]
push!(my_friends, "Janice")
# results in ["Rachel", "Monica", "Phoebe", "Joey", "Chandler", "Ross", "Janice"]

pop!(my_friends)
# results in ["Rachel", "Monica", "Phoebe", "Joey", "Chandler", "Ross"]

my_friends_backup = my_friends
my_friends_backup[1] = "CHANGED"
my_friends
# ["CHANGED", "Monica", "Phoebe", "Joey", "Chandler", "Ross"]

my_friends_safe_backup = copy(my_friends)
# creates a new copy in memory
```

<!-- show tuple -->
```diff 1:6 subtitle="Tuples"

```
<!-- show named tuple -->
```diff 8:12 subtitle="NamedTuples"

```
<!-- show Dictionary -->
```diff 14:25 subtitle="Dictionaries"

```
<!-- show Array -->
```diff 27:32 subtitle="Arrays"

```
<!-- show copy -->
```diff 34:40 subtitle="Safe Copy"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Loops"
n = 0
while n < 10
    n += 1
    println(n)
end

my_friends = ["Rachel", "Monica", "Phoebe", "Joey", "Chandler", "Ross"]
i = 1
while i <= length(my_friends)
    friend = my_friends[i]
    println("Hi $friend, it's great to see you!")
    i += 1
end

for n in 1:10
    println(n)
end
# prints 1 through 10 inclusively

for n in 1:3:10
    println(n)
end
# prints 1 4 7 10

for friend in my_friends
    println("Hi $friend, it's great to see you!")
end

A = fill(0, (4, 5))
for i in 1:4
    for j in 1:5
        A[i, j] = i + j
    end
end

B = fill(0, (4, 5))
for i in 1:4, j in 1:5
    B[i, j] = i + j
end

C = [i + j for i in 1:4, j in 1:5]
```

<!-- show while -->
```diff 1:5 subtitle="While Loops"

```
<!-- show while with array -->
```diff 7:13 subtitle="While Loops"

```
<!-- show for loop -->
```diff 15:18 subtitle="For Loops"

```
<!-- show for loop every 3 -->
```diff 20:23 subtitle="For Loops"

```
<!-- show iterator -->
```diff 25:27 subtitle="For Loops"

```
<!-- show 2d array -->
```diff 29:34 subtitle="Multi-dimension Loop"

```
<!-- show 2d array -->
```diff 36:39 subtitle="Multi-dimension Loop"

```
<!-- show 2d array -->
```diff 41 subtitle="Array Comprehensions"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Conditionals"
if (N % 3 == 0) && (N % 5 == 0)
    println("FizzBuzz")
elseif N % 3 == 0
    println("Fizz")
elseif N % 5 == 0
    println("Buzz")
else
    println(N)
end

a ? b : c

false && println("This will not print")
true && println("This will print")

false || println("This will also print")
true || println("This will print as well")
```

<!-- show conditional keywords -->
```diff 1[1:2],3[1:6],5[1:6],7[1:4],9[1:3] subtitle="If Statements"

```
<!-- show Ternary -->
```diff 11[3,7] subtitle="Ternary Statements"

```
<!-- show Short circuit -->
```diff 13:17 subtitle="Short Circuit"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Functions"
function sayhi(name)
    println("Hi $name, it's great to see you!")
end
sayhi("C-3PO")
# "Hi C-3PO, it's great to see you!"

function f(x)
    x^2
end
f(42)
# 1764

sayhi2(name) = println("Hi $name, it's great to see you!")
f2(x) = x^2
# same behavior

sayhi_lambda = (first_name, last_name) -> println("Hi $first_name $last_name, it's great to see you!")

v = [3, 5, 2]

sort(v)
# returns [2, 3, 5] but v == [3, 5, 2]

sort!(v)
# returns [2, 3, 5] and v == [2, 3, 5]

# higher-order function
map(f, [1, 2, 3])
# returns [1, 3, 9]

broadcast(f, [1, 2, 3])
# the same as this
f.([1, 2, 3])

A = [i + 3j for j in 0:2, i in 1:3]
# 3x3 Array{Int64, 2}:
# 1 2 3
# 4 5 6
# 7 8 9

f(A)
# 3x3 Array{Int64, 2}:
#  30  36  42
#  66  81  96
# 102 126 150

f.(A)
# 3x3 Array{Int64, 2}:
#  1  4  9
# 16 25 36
# 49 64 81
```

<!-- show function -->
```diff 1:5 subtitle="Functions"

```
<!-- show function -->
```diff 7:11 subtitle="Functions"

```
<!-- show function -->
```diff 13:15 subtitle="Functions"

```
<!-- show lambda -->
```diff 17 subtitle="Lambda Functions"

```
<!-- show mutating -->
```diff 19:25 subtitle="Mutating Functions"

```
<!-- show higher order function -->
```diff 27:33 subtitle="Higher-Order Functions"

```
<!-- show dot operator -->
```diff 33 subtitle="Dot Operator"

```
<!-- show dot operator -->
```diff 35:39 subtitle="Dot Operator"

```
<!-- show dot operator -->
```diff 41:45 subtitle="Dot Operator"

```
<!-- show dot operator -->
```diff 47:51 subtitle="Dot Operator"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Multiple Dispatch"
f(x) = x^2
f(10)
# 100

foo(x::String, y::String) = println("X and Y are both strings")
foo(x::Int, y::Int) = println("X and Y are both Ints")
foo(x::Number, y::Number) = println("X and Y are both Numbers")
foo(x::Any, y::Any) = println("X and Y could be anything!")

bar(x::Any)::String = "The result will be a string"
```

<!-- show function -->
```diff 5[6:13,17:24,55:61],6[6:10,14:18,49:52],7[6:13,17:24,55:61],8[6:10,14:18,49:57] subtitle="Multiple Dispatch"

```
<!-- show return type -->
```diff 10[12:19] subtitle="Return Types"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Packages"
using Pkg
Pkg.add("Example")

using Example

Pkg.add("Plots")
using Plots

Pkg.add("BenchmarkTools")
using BenchmarkTools

a = rand(10^7) # 1D vector of random numbers, uniform on [0,1)

using Libdl
C_code = """
#include <stddef.h>
double c_sum(size_t n, double *X) {
    double s = 0.0;
    for (size_t i = 0; i < n; i++) {
        s += X[i]
    }
    return s;
}
"""

const Clib = tempname() # make a temporary file

# compile to a shared library by piping C_code to gcc

open(`gcc -fPIC -O3 -msse3 -xc -shared -o $(Clib * "." * Libdl.dlext) -`, "w") do f
    print(f, C_code)
end

# define a Julia function that calls the C function:
c_sum(X::Array{Float64}) = ccall(("c_sum", Clib), Float64, (Csize_t, Ptr{Float64}), length(X), X)

c_bench = @benchmark c_sum($a)

Pkg.add("PyCall")
using PyCall

pysum = pybuiltin("sum")
pysum(a)

py"""
def py_sum(A):
    s = 0.0
    for a in A:
        s += a
    return s
"""

sum_py = py"py_sum"
sum_py(a)
```

<!-- show packages -->
```diff 1:2 subtitle="Using Packages"

```
<!-- show packages -->
```diff 4:10 subtitle="Using Packages"

```
<!-- show ccall -->
```diff 14:24 subtitle="Calling C Code"

```
<!-- show ccall -->
```diff 30:35 subtitle="Calling C Code"

```
<!-- show pycall -->
```diff 39:40 subtitle="Calling Python Code"

```
<!-- show pycall -->
```diff 42:43 subtitle="Calling Python Code"

```
<!-- show pycall -->
```diff 45:54 subtitle="Calling Python Code"

```

</CodeSurfer>

---

<CodeSurfer>

```erlang title="Distributed Code"
for i in 1:100
    println(i^2)
end
```

```erlang title="Distributed Code"
Pkg.add("Distributed")
using Distributed

@sync @distributed for i in 1:100
    println(i^2)
end
```

```erlang title="Process Mapping"
squares = pmap(x -> x ^ 2, 1:10)
println(squares)
```

</CodeSurfer>

---

# Refs:
Julia for beginners: A springboard to machine learning for all ages
- Tanmay Bakshi

Intro to Julia (Version 1.0)
- Jane Herriman

[codesurfer](https://codesurfer.pomb.us)
